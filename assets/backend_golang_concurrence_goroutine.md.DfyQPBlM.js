import{_ as o,c as e,o as t,a3 as a}from"./chunks/framework.DNC8YNX_.js";const r="/blog/assets/goroutine.BLLwt_0s.png",G=JSON.parse('{"title":"Goroutine","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"backend/golang/concurrence/goroutine.md","filePath":"backend/golang/concurrence/goroutine.md","lastUpdated":1688743312000}'),n={name:"backend/golang/concurrence/goroutine.md"},c=a('<h1 id="goroutine" tabindex="-1">Goroutine <a class="header-anchor" href="#goroutine" aria-label="Permalink to &quot;Goroutine&quot;">​</a></h1><h2 id="设计原理" tabindex="-1">设计原理 <a class="header-anchor" href="#设计原理" aria-label="Permalink to &quot;设计原理&quot;">​</a></h2><p>在接触 <code>goroutine</code> 之前，我们先来了解一下 进程、线程、协程的区别</p><ul><li>进程</li></ul><p>进程是操作系统进行资源分配的基本单位，每个进程都有自己的独立内存空间。每个进程占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大。</p><ul><li>线程</li></ul><p>线程又叫做轻量级进程，是进程的一个实体，是处理器任务调度和执行的基本单位。线程只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><ul><li>协程</li></ul><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p><code>goroutine</code> 是 golang 中对协程的具体实现，<code>goroutine</code> 让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 <code>runtime</code> 调度，转移到其他可运行的线程上。</p><p><code>goroutine</code> 非常轻量，一个 <code>goroutine</code> 只占几 KB，并且这几 KB 就足够 <code>goroutine</code> 运行完，这就能在有限的内存空间内支持大量 <code>goroutine</code>，支持了更多的并发。虽然一个<code>goroutine</code> 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，<code>runtime</code> 会自动为 <code>goroutine</code> 分配。</p><h2 id="gmp模型" tabindex="-1">GMP模型 <a class="header-anchor" href="#gmp模型" aria-label="Permalink to &quot;GMP模型&quot;">​</a></h2><p>在 <code>Go</code> 中，线程是运行 <code>goroutine</code> 的实体，调度器的功能是把可运行的 <code>goroutine</code> 分配到工作线程上。</p><img src="'+r+'" alt="GMP模型" style="zoom:50%;"><h3 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h3><ol><li><p><strong>全局队列</strong>（Global Queue）：存放等待运行的 G。</p></li><li><p><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过256个。新建 G 时，G 优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</p></li><li><p><strong>P列表</strong>：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS (可配置)个。</p></li><li><p><strong>M</strong>：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己P的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</p></li></ol><blockquote><p><strong>有关P和M的个数问题</strong></p></blockquote><ol><li>M的数量</li></ol><p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p><p>在默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数，我们也可以在程序中使用 <code>runtime.GOMAXPROCS</code> 来改变最大的活跃线程数。</p><ol start="2"><li>P的数量</li></ol><p>因为调度器在启动时就会创建 <code>GOMAXPROCS</code> 个处理器，所以 Go 语言程序的处理器数量一定会等于 <code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上。</p><h3 id="设计策略" tabindex="-1">设计策略 <a class="header-anchor" href="#设计策略" aria-label="Permalink to &quot;设计策略&quot;">​</a></h3><p>复用线程：避免频繁的创建、销毁线程，而是对线程的复用。</p><ul><li>work stealing机制</li></ul><p>当本线程无可运行的 G 时，尝试从全局 G 队列偷取 G，如果全局队列没有 G 的话，再从其它线程绑定的 P 队列偷取 G。</p><ul><li>hand off机制</li></ul><p>当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</p>',28),i=[c];function l(d,u,p,s,g,P){return t(),e("div",null,i)}const _=o(n,[["render",l]]);export{G as __pageData,_ as default};
